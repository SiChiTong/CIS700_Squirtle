#include <ros/ros.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <actionlib/client/simple_action_client.h>
#include <hector_nav_msgs/GetRobotTrajectory.h>
#include <geometry_msgs/PoseStamped.h>
#include "std_msgs/String.h"

typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> MoveBaseClient;



int main(int argc, char** argv){
  ros::init(argc, argv, "simple_exploration");
  ros::NodeHandle nh;

  // create a service client of /get_exploration_path (generated by hector_exploration_node)
  ros::ServiceClient explo_path_getter 
  		= nh.serviceClient<hector_nav_msgs::GetRobotTrajectory>("get_exploration_path");

  //create the movebase action client ac
  MoveBaseClient ac("move_base", true);

  ros::Publisher say_pub = nh.advertise<std_msgs::String>("/mouth/string_to_say",10);


  
  while(ros::ok()){
    //
    while(!explo_path_getter.waitForExistence(ros::Duration(5.0))){
      ROS_INFO("Waiting for the exploration planner server to come up");
    }

    //call the service 
    hector_nav_msgs::GetRobotTrajectory get_path_srv;
    explo_path_getter.call(get_path_srv);
    ROS_INFO("exploration path get.");


    if (get_path_srv.response.trajectory.poses.size() == 0)
    {
      ROS_ERROR_STREAM("Exploration done. (planner path empty)");
      break; 
    }

    //get the last pose in trajectory (which is the goal)
    int path_length = get_path_srv.response.trajectory.poses.size();
    geometry_msgs::PoseStamped last_pose = get_path_srv.response.trajectory.poses[path_length-1];

    //Now we have the goal from hector_exploration_node, we need to pass it to move_base goal

    //wait for move_base server, this part is necessary 
    while(!ac.waitForServer(ros::Duration(5.0))){
      ROS_INFO("Waiting for the move_base action server to come up");
    }

    //Send goal to move_base
    move_base_msgs::MoveBaseGoal goal;
    goal.target_pose.header.frame_id = "map";
    goal.target_pose.header.stamp = ros::Time::now();
    goal.target_pose.pose = last_pose.pose;


    ac.sendGoal(goal);
    ROS_INFO("Sent goal to movebase");

    
    //voice info
    std_msgs::String string_to_say;
    string_to_say.data = "destination found";
    say_pub.publish(string_to_say);
    string_to_say.data = "moving";
    say_pub.publish(string_to_say);
    
    //Wait until goal reached or aborted
    ac.waitForResult();

    
    if(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED){
      ROS_INFO("Succeed, looking for a new goal...");
      //voice info
      //std_msgs::String string_to_say;
      string_to_say.data = "destination has been reached, looking for a new one";
      say_pub.publish(string_to_say); 
    }
    else{
      //voice info
      //std_msgs::String string_to_say;
      string_to_say.data = "destination can not be reached, looking for a new one";
      say_pub.publish(string_to_say);
      ROS_INFO_STREAM(ac.getState().toString()<<": Failed to reach goal, looking for a new goal...");
    }
    ros::spinOnce();
    
    // Wait for 1 second before going to next goal
    // This will allow the mapper to update
    ros::Duration(1).sleep(); 

  }
  return 0;
}